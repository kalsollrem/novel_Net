<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.project.novelnet.repository.SearchMapper">
    <resultMap type="com.project.novelnet.Vo.NovelVO" id="novelVO">
        <result column="u_num" property="u_num"/>
        <result column="n_title" property="n_title"/>
        <result column="n_introduction" property="n_introduction"/>
        <result column="n_type" property="n_type"/>
        <result column="m_date" property="m_date"/>
        <result column="n_monopoly" property="n_monopoly"/>
        <result column="n_fin" property="n_fin"/>
    </resultMap>

    <!--  소설검색  -->

    <!--  게시물 검색 + 번호매기기  -->
    <select id="findBest" resultType="com.project.novelnet.Vo.NovelVO">
        SELECT A.n_num, A.u_num, A.n_title, A.n_introduction, A.n_cover, A.n_fin, b.count, c.u_nick as nick
        FROM novel A
        <if test="findtype.equals('count')">
            LEFT JOIN (select sum(m_count)as count, n_num from memo group by n_num)B
            on A.n_num = B.n_num
        </if>
        <if test="findtype.equals('best')">
            LEFT JOIN (select sum(m_good)as count, n_num from memo group by n_num)B
            on A.n_num = B.n_num
        </if>
        <if test="findtype.equals('bookmark')">
            LEFT JOIN (select count(bm_num) as count, n_num from bookmark group by n_num)B
            on A.n_num = B.n_num
        </if>
        LEFT join user C
        on A.u_num = C.u_num
        order by count desc
        limit #{limit}
    </select>

    <!-- collection = list냐 array냐    -->
    <!-- item       = #{}에 들어갈 명칭   -->
    <!-- separator  = 배열 내에서 나누는 기준(일반적으로 ',') -->
    <!-- open       = 시작시 들어갈 단어   -->
    <!-- close      = 마무리에 들어갈 단어  -->
    <!-- <![CDATA[ < ]]>  = '<'사용시 오류뜸  -->
    <select id="findPdPick" parameterType="java.util.List" resultType="com.project.novelnet.Vo.NovelVO">
        (select A.n_num, A.n_title, A.n_cover, A.n_monopoly, A.n_stop, B.u_nick as nick, @rownum := 0 AS noType
        from novel A
        Left join user B
        on A.u_num = B.u_num
        ,(SELECT @rownum :=0) AS r
        where A.n_num IN
        <foreach collection="list" item="pdlist" separator="," open="(" close=")" index="index">
           #{pdlist}
        </foreach>
        and not n_num is null
        limit 6)
        UNION ALL
        (select A.n_num, A.n_title, A.n_cover, A.n_monopoly, A.n_stop, B.u_nick as nick, @rownum := 1 AS noType
        from novel A
        Left  join user B
        on A.u_num = B.u_num
        ,(SELECT @rownum := 0) AS r
        where A.n_monopoly = 'only' and A.n_stop <![CDATA[ < ]]> 5
        order by rand()
        limit 6)
    </select>

    <!-- 북마크 검색-->
    <!-- LIMIT 18446744073709551615 가 있어야 재정렬됨 -->
    <!-- ROWNUM으로 페이징처리-->
    <!-- 번호매기기 추가 예정 -->
    <select id="getBookmarkList" resultType="com.project.novelnet.Vo.NovelVO">
    select origin.*, @ROWNUM := @ROWNUM + 1 as ROWNUM from(
        select
            B.u_num, B.n_num,
            A.nick, A.n_title, A.n_cover, A.n_introduction, A.n_fin, A.n_type, A.n_monopoly,
            C.m_num as last_chapter,
            D.rnum, D.count as n_count, D.m_good as n_good, IFNULL(D.b_stop,0)as n_stop, D.n_chapters,
            E.All_tag,
            date_format(F.m_date, '%Y년 %c월 %d일') as n_date, (TIMESTAMPDIFF(HOUR , F.m_date, now()))as newMemo
        from
            (select * from bookmark where u_num = '20' group by n_num)B
        left join
            (select nA.*, uB.u_nick as nick from novel nA left join user uB on nA.u_num = uB.u_num) A
        on
            A.n_num = B.n_num
        left outer join
            (select * from (select n_num, m_num, u_num from m_record where u_num = #{u_num} order by n_num asc, mr_num desc LIMIT 18446744073709551615) as m_record group by n_num) C
        on
            A.n_num = C.n_num
        left join
            (select
                row_number() over(partition by m1.n_num order by m1.m_num asc) as rnum, m1.m_num, m1.n_num, m1.m_type,
                m2.count , m2.m_good, m2.b_stop, m2.n_chapters
            from (select row_number() over(partition by n_num order by m_num asc)as rnum, n_num, m_num, m_type from memo) m1
            left join
                (select n_num as t, sum(m_count) as count, sum(m_good) as m_good, sum(b_stop) as b_stop, count(case when m_type='ep' then 1 end) as n_chapters
                from memo group by n_num) m2
            on m1.n_num = m2.t
            where m_type='ep'
            ) D
        on
            C.n_num = D.n_num and D.m_num = C.m_num
        left join
            (select n_num, group_concat(h_tag separator' ') as All_tag
                from (select n_num, concat(<![CDATA['<div class="searched_tagcard">',h_tag,'</div>']]>)as h_tag from hashtag order by n_num asc, t_carte asc)tagChange
                group by n_num order by h_tag) E
        on
            A.n_num = E.n_num
        left join (select * from (select n_num, m_date from memo order by m_date desc LIMIT 18446744073709551615) datapack group by n_num) F
        on
            A.n_num = F.n_num
        <choose>
            <when test="fin.equals('doing')">
                where n_fin = 'doing'
            </when>
            <when test="fin.equals('done')">
                where n_fin = 'done'
            </when>
            <otherwise></otherwise>
        </choose>
        group by A.n_num
        <choose>
            <when test="newOld.equals('asc')">
                order by F.m_date asc
            </when>
            <otherwise>
                order by F.m_date desc
            </otherwise>
        </choose>
    ) as origin, (select @ROWNUM :=0) Tab
    where n_title like CONCAT('%',#{keyword},'%') or all_tag like CONCAT('%',#{keyword},'%')
    limit 0,10;
    </select>
</mapper>

<!--구버전 쿼리-->
<!--A.n_num, A.u_num, A.nick, A.n_title, A.n_cover, A.n_introduction, A.n_fin, A.n_type, A.n_monopoly,-->
<!--B.m_date as n_date, B.count as n_count, B.m_good as n_good, B.b_stop as n_stop, B.n_chapters, B.rnum,-->
<!--C.m_num as last_chapter,-->
<!--E.All_tag-->
<!--from (select nA.*, uB.u_nick as nick from novel nA left join user uB on nA.u_num = uB.u_num) A-->
<!--left join-->
<!--(select m1.rnum, m1.m_num, m1.n_num, m1.m_date, m1.m_type,-->
<!--m2.count , m2.m_good, m2.b_stop, m2.n_chapters-->
<!--from (select row_number() over(partition by n_num order by m_num desc)as rnum, n_num, m_num, m_date, m_type from memo) m1-->
<!--left join (select n_num as t, sum(m_count) as count, sum(m_good) as m_good, sum(b_stop) as b_stop, count(case when m_type='ep' then 1 end) as n_chapters-->
<!--from memo-->
<!--group by n_num) m2-->
<!--on m1.n_num = m2.t-->
<!--where m_type='ep'-->
<!--order by m1.m_date desc LIMIT 18446744073709551615) B-->
<!--on-->
<!--A.n_num = B.n_num-->
<!--join-->
<!--(select * from (select n_num, m_num, u_num from m_record where u_num = #{u_num} order by n_num asc, mr_num desc LIMIT 18446744073709551615) as m_record group by n_num) C-->
<!--on-->
<!--A.n_num = c.n_num-->
<!--left join-->
<!--(select n_num, group_concat(h_tag separator',') as All_tag from hashtag group by n_num order by h_tag) E-->
<!--on-->
<!--A.n_num = E.n_num-->
<!--group by A.n_num-->
<!--order by m_date desc;-->